# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    instruction_parsing.txt                            :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: louisa <louisa@student.42.fr>              +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/03/10 16:14:31 by lboudjem          #+#    #+#              #
#    Updated: 2023/03/24 21:43:27 by louisa           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


                Parcourir jusqu'a trouver des quotes OU un pipe OU la '\0'
                
si je trouve une quote :
    - verifier que la quote se referme
    - avant que la quote se referme, sil y a un pipe -> invalide
si je trouve un pipe :
    - je stock tout ce que j'ai recup dans une variable
    - je formate* la variable pour la mettre ET je la met dans un element de la liste
    - on recommence jusqu'a '\0'
si je trouve un '\0' :
    - je met tout dans un element de la liste en la formatant*
si je trouve un export :
    - le egal doit etre coller (format : mot=truc)
    - faire un arg avec tout ce qu'il ya avant le =
    - faire un bloc avec ce qu'il y a apres le = jusqu au prochain espace ou '\0'
    - si ya rien apres le egal = arg NULL
    - si ya meme pas de = : je fais rien jusqu au prochain pipe/fin de ligne/redirection
    - aussi, ignorer tous les mots jusquau prochain pipe/fin de ligne/redirection

                            *Formater la ligne recuperee

- Parcourir et voir si je trouve une quote simple ou un $ :
    - si quote : avant que la quote se referme, s'il y a un $ -> $ invalide
    - sinon : Si il y a un $, le remplacer par sa valeur dans l'env 
    - si $? : remplacer par exit_status (faut convertir >:()
    - si ya un $ avec rien apres on fait rien
    - si un $ ne correspond a rien, remplacer par une chaine vide
- Parcourir pour chercher les redirections
    - Juste avant la redirection:
        - Si il ya un chiffre coller a la rediction -> fd
        - si il n y a rien, ajouter le fd standard (0 for < and <<, 1 for > and >>)
        - PAS SURE : si il ya un nom sous le format {NAME} coller a la redirection
    - Juste apres la redirection:
        - Si il n y a rien apres : erreur de parsing
        - Si il ya un nom -> c'est arg
- Stocker chaque 'mot' dans une case du tableau arg TANT QUE ce n'est ni un $ ni une redirection


                    A la fin, reparcourir la liste des redirection io

- Si je trouve une redirection de type 2 (<<), appeler la fonction here_doc
- dans le here_doc : interpreter les $ 

                        structure des lignes de commandes
line->arg[0] = commande (echo, ls, cat..)
line->arg[1] = arguments (tout ce qu'il y a apres la cmd jusqu au prochain pipe ou \0 : sauf redirection)
- Exemples :
echo hello                     coucou = hello coucou
echo "hello                     coucou" = hello                     coucou

                                Code d'erreur
Missing quote : 2

Autre:
- Faire une fonction clear all qui clear toutes les lists entre deux commandes entrés par le user

        Offrir des gatos a titi
- Un titi bien nourrit travaillera mieux et sera de meilleur humeur
- Un effet secondaire est un sentiment de réussite, de grâce, d'amour infinie et d'apaisement


- A ne pas oublier:
export qui fait des gros leaks
casser tous les mallocs
exp"$hello"ort""''""
quotes non fermées dans les heredocs
cat Makefile > z | cat z | wc -l > r | ls vs cat Makefile > z | cat z | wc -l > r |ls

- Fait (normalement) (a tester quand meme) :
export test=truc
> log2
">"
export TEST='""'
yes $USER
export test="truc truc"
echo $ejknfenf hey
ajouter le here_doc
penser a free hihi
exporte test=truc abort
arg des redirection "'test'"
< log suprime pas la redirection
export test : ca le met dans export et pas dans env
dans les redirections : skip tout ce quil ya entre quote
export test= : dans env ca met test=(rien)
supprimer les redirection et leurs args juste apres
renvoie code erreur specifique en cas de bloc null (2 par exemple)
(echo coucou |   |) DIFFERENT DE (echo coucou | " "  | " ")
missing quote
"" -> permission denied (demander a titi)
remonter correctement l'erreur missing quote
echo "$""USER"

                        Exemples chiants a tester:

echo '"'"$USER"'"'
echo mdrr 1<>coucou
echo mdrr 2<>coucou
echo coucou > "ihi aha"ihi
echo >mdr>hey>>sarace \sal"mdr"
echo <hey1<h'ey2'
echo bonjour >hey >>hey2 >>hey3
>> e
ls $HOME/Desktop
echo “$PATH”
echo "$PATH$PWD"
echo -n a '' b '' c '' d
e"ch"o bonjour
echo\ bonjour
exit ' 3'
exit -1
exit -9223372036854775808
exit 9223372036854775807
exit +3 
exit 2000000
exit -2147483649
exit 0 bonjour ->	bash: exit: too many arguments
exit coucou    ->	exit: coucou: numeric argument required
cat Makefile | ./minishell
Essayer d'exécuter un mini shell dans minishell ./minishell et tester les signaux et le man de commandes
./minishell coucou (doit renvoyer une erreur)
echo "$ejnzefc" hey
./minishell 2>lol (redirection de stderr, aucuns messages d'erreurs ne doivent s'imprimer dans le terminal)
env -i ./minishell (= lance sans les var d’env)
commande yes avec les signaux et $?
echo $ejknfenf hey
