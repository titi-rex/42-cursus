# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    instruction_parsing.txt                            :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: lboudjem <lboudjem@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/03/10 16:14:31 by lboudjem          #+#    #+#              #
#    Updated: 2023/03/17 16:40:06 by lboudjem         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


                Parcourir jusqu'a trouver des quotes OU un pipe OU la '\0'
                
si je trouve une quote :
    - verifier que la quote se referme
    - avant que la quote se referme, sil y a un pipe -> invalide
si je trouve un pipe :
    - je stock tout ce que j'ai recup dans une variable
    - je formate* la variable pour la mettre ET je la met dans un element de la liste
    - on recommence jusqu'a '\0'
si je trouve un '\0' :
    - je met tout dans un element de la liste en la formatant*
si je trouve un export :
    - le egal doit etre coller (format : mot=truc)
    - faire un arg avec tout ce qu'il ya avant le =
    - faire un bloc avec ce qu'il y a apres le = jusqu au prochain espace ou '\0'
    - si ya rien apres le egal = arg NULL
    - si ya meme pas de = : je fais rien jusqu au prochain pipe/fin de ligne/redirection
    - aussi, ignorer tous les mots jusquau prochain pipe/fin de ligne/redirection

                            *Formater la ligne recuperee

- Parcourir et voir si je trouve une quote simple ou un $ :
    - si quote : avant que la quote se referme, s'il y a un $ -> $ invalide
    - sinon : Si il y a un $, le remplacer par sa valeur dans l'env 
    - si $? : remplacer par exit_status (faut convertir >:()
    - si un $ ne correspond a rien, remplacer par une chaine vide
- Parcourir pour chercher les redirections
    - Juste avant la redirection:
        - Si il ya un chiffre coller a la rediction -> fd
        - si il n y a rien, ajouter le fd standard (0 for < and <<, 1 for > and >>)
        - PAS SURE : si il ya un nom sous le format {NAME} coller a la redirection
    - Juste apres la redirection:
        - Si il n y a rien apres : erreur de parsing
        - Si il ya un nom -> c'est arg
- Stocker chaque 'mot' dans une case du tableau arg TANT QUE ce n'est ni un $ ni une redirection


                    A la fin, reparcourir la liste des redirection io

- Si je trouve une redirection de type 2 (<<), appeler la fonction here_doc
- dans le here_doc : interpreter les $ 

                        structure des lignes de commandes
line->arg[0] = commande (echo, ls, cat..)
line->arg[1] = arguments (tout ce qu'il y a apres la cmd jusqu au prochain pipe ou \0 : sauf redirection)
- Exemples :
echo hello                     coucou = hello coucou
echo "hello                     coucou" = hello                     coucou


Autre:
- Faire une fonction clear all qui clear toutes les lists entre deux commandes entrés par le user

        Offrir des gatos a titi
- Un titi bien nourrit travaillera mieux et sera de meilleur humeur
- Un effet secondaire est un sentiment de réussite, de grâce, d'amour infinie et d'apaisement


- A penser:
echo $ print un $
penser a free hihi