# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    instruction_parsing.txt                            :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: lboudjem <lboudjem@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/03/10 16:14:31 by lboudjem          #+#    #+#              #
#    Updated: 2023/03/29 13:59:16 by lboudjem         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


                Parcourir jusqu'a trouver des quotes OU un pipe OU la '\0'
                
si je trouve une quote :
    - verifier que la quote se referme
    - avant que la quote se referme, sil y a un pipe -> invalide
si je trouve un pipe :
    - je stock tout ce que j'ai recup dans une variable
    - je formate* la variable pour la mettre ET je la met dans un element de la liste
    - on recommence jusqu'a '\0'
si je trouve un '\0' :
    - je met tout dans un element de la liste en la formatant*
si je trouve un export :
    - le egal doit etre coller (format : mot=truc)
    - faire un arg avec tout ce qu'il ya avant le =
    - faire un bloc avec ce qu'il y a apres le = jusqu au prochain espace ou '\0'
    - si ya rien apres le egal = arg NULL
    - si ya meme pas de = : je fais rien jusqu au prochain pipe/fin de ligne/redirection
    - aussi, ignorer tous les mots jusquau prochain pipe/fin de ligne/redirection

                            *Formater la ligne recuperee

- Parcourir et voir si je trouve une quote simple ou un $ :
    - si quote : avant que la quote se referme, s'il y a un $ -> $ invalide
    - sinon : Si il y a un $, le remplacer par sa valeur dans l'env 
    - si $? : remplacer par exit_status (faut convertir >:()
    - si ya un $ avec rien apres on fait rien
    - si un $ ne correspond a rien, remplacer par une chaine vide
- Parcourir pour chercher les redirections
    - Juste avant la redirection:
        - Si il ya un chiffre coller a la rediction -> fd
        - si il n y a rien, ajouter le fd standard (0 for < and <<, 1 for > and >>)
        - PAS SURE : si il ya un nom sous le format {NAME} coller a la redirection
    - Juste apres la redirection:
        - Si il n y a rien apres : erreur de parsing
        - Si il ya un nom -> c'est arg
- Stocker chaque 'mot' dans une case du tableau arg TANT QUE ce n'est ni un $ ni une redirection


                    A la fin, reparcourir la liste des redirection io

- Si je trouve une redirection de type 2 (<<), appeler la fonction here_doc
- dans le here_doc : interpreter les $ 

                        structure des lignes de commandes
line->arg[0] = commande (echo, ls, cat..)
line->arg[1] = arguments (tout ce qu'il y a apres la cmd jusqu au prochain pipe ou \0 : sauf redirection)
- Exemples :
echo hello                     coucou = hello coucou
echo "hello                     coucou" = hello                     coucou


Autre:
- Faire une fonction clear all qui clear toutes les lists entre deux commandes entrés par le user

        Offrir des gatos a titi
- Un titi bien nourrit travaillera mieux et sera de meilleur humeur
- Un effet secondaire est un sentiment de réussite, de grâce, d'amour infinie et d'apaisement

Loulounotes pour les quotes :
- faire une fonction clear \
- faire une fonction protect \
- faire une fonction protect ' "
- modifier la fonction qui delete les quotes

- parcourir et proteger les \
- remplacer les var env par leur valeur => supprime les auotes inutiles 
- value = value avec ' et " proteges 
- je continu mon code tranquilloulou
- je supprime tous les 1er \

export test="''"
value = ''

echo $test 'coucou "ihi"'
value = \'\'
echo \'\' 'coucou"ihi"'


echo " $test \ ' joho ' "
echo  $test \ ' joho ' 
echo $test \\ \' joho \'
echo \"\" \\ \' joho \'


export test="echo 'coucou'"
value = echo \'coucou\'

echo \'jojo\' \\
echo 'jojo' \
 

- A ne pas oublier:
cat <<"<<""<"
<<"<">>"<"
export test='echo C"est > $out'

- Fait (normalement) (a tester quand meme) :
export TEST='""' -> puis echo "$TEST"
export test='""' puis echo "'$test'"
export test="''" puis echo $test ''
export test='echo $USER C"es"t'
$ et redirection dans var env
$test (avec test vide)
casser tous les mallocs
echo \\ : Heap overflow
echo "\" : Heap overflow
echo coucou > "ihi aha"ihi
here_doc +  fleche du haut
export test=truc
| echo coucou
export test="\"
echo' a'
tab
<< ""
>>> log : leaks
>>>>> log
> >> log
><<log
> log2
">"
|
|||||||
echo $
echo hello |
<"" leaks
export TEST='""'
yes $USER
exp"$hello"ort""''""
export test="truc truc"
echo $ejknfenf hey
export cmd="echo 'bonjour""ihi'"
ajouter le here_doc
penser a free hihi
exporte test=truc abort
| ne fait pas error parsing
arg des redirection "'test'"
export lol2="\'" puis echo $lol2
export TEST="''" -> puis echo $TEST
export TEST='""' -> puis echo $TEST
export qui fait des gros leaks
< log suprime pas la redirection
quotes non fermées dans les here_doc
<< 'test' et << "test" ne doivent pas gerer les expansions
export A=a B=b C=c D=d E=e F=f G=g H=h I=i J=j K=k L=l M=m N=n O=o P=p Q=q R=r
cat Makefile > z | cat z | wc -l > r | ls vs cat Makefile > z | cat z | wc -l > r |ls
export test : ca le met dans export et pas dans env
dans les redirections : skip tout ce quil ya entre quote
export test= : dans env ca met test=(rien)
supprimer les redirection et leurs args juste apres
renvoie code erreur specifique en cas de bloc null (2 par exemple)
(echo coucou |   |) DIFFERENT DE (echo coucou | " "  | " ")
missing quote
"" -> permission denied (demander a titi)
remonter correctement l'erreur missing quote
echo "$""USER"

                        Exemples chiants a tester:

echo '"'"$USER"'"'
export test=$test"coucou"
echo mdrr 1<>coucou
echo mdrr 2<>coucou
echo coucou > "ihi aha"ihi
echo >mdr>hey>>sarace \sal"mdr"
echo <hey1<h'ey2'
echo bonjour >hey >>hey2 >>hey3
>> e
ls $HOME/Desktop
echo “$PATH”
echo "$PATH$PWD"
echo -n a '' b '' c '' d
e"ch"o bonjour
echo\ bonjour
exit ' 3'
exit -1
exit -9223372036854775808
exit 9223372036854775807
exit +3 
exit 2000000
exit -2147483649
exit 0 bonjour ->	bash: exit: too many arguments
exit coucou    ->	exit: coucou: numeric argument required
cat Makefile | ./minishell
Essayer d'exécuter un mini shell dans minishell ./minishell et tester les signaux et le man de commandes
./minishell coucou (doit renvoyer une erreur)
echo "$ejnzefc" hey
./minishell 2>lol (redirection de stderr, aucuns messages d'erreurs ne doivent s'imprimer dans le terminal)
env -i ./minishell (= lance sans les var d’env)
commande yes avec les signaux et $?
